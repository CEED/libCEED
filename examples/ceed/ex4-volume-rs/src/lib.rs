#![no_std]
#![feature(asm_experimental_arch, abi_ptx, core_intrinsics)]
use core::ffi::c_void;
use core::intrinsics::abort;
use core::panic::PanicInfo;

#[doc = " A structure used to pass additional data to f_build_mass"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BuildContext {
    pub dim: i32,
    pub space_dim: i32,
}

/*#[cfg(target = "nvptx64-nvidia-cuda")]
pub fn abort() -> ! {
    unsafe { asm!("trap;") }
    unreachable!();
}*/

//#[cfg(target = "nvptx64-nvidia-cuda")]
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    abort()
}

#[no_mangle]
pub unsafe extern "C" fn build_mass_rs(
    ctx: *mut c_void,
    q: i32,
    in_: *const *const f64,
    out: *mut *mut f64,
) -> i8 {
    let ctx: *mut BuildContext = unsafe { core::mem::transmute(ctx) };
    let ctx: &mut BuildContext = &mut *ctx;

    //in_arr needs to be a pointer to a (2d) array
    // todo: figure out how to get 2d indexing into a 1d array or convert 1d array to 2d array
    // maybe find a crate

    /*let j = unsafe { core::slice::from_raw_parts(in_, q as usize) };

    for (i, _) in j.iter().enumerate() {
        let a = (j.get_unchecked(i));
        q_data[i] = (j.get_unchecked(i)) * (w.get_unchecked(i));
    }*/

    let in_slice = core::slice::from_raw_parts(in_, 2); // assuming 2 inputs: J and w

    let j_ptr = in_slice[0];
    let w_ptr = in_slice[1];

    let j = core::slice::from_raw_parts(j_ptr, (q * ctx.dim) as usize); // J is 1D now
    let w = core::slice::from_raw_parts(w_ptr, q as usize);

    let out_slice = core::slice::from_raw_parts_mut(out, 1);
    let q_data = core::slice::from_raw_parts_mut(out_slice[0], q as usize);

    // Compute q_data[i] = J[0][0][i] * w[i], now with J as 1D: J[i]
    match ctx.dim * 10 + ctx.space_dim {
        11 => {
            for i in 0..q as usize {
                q_data[i] = j.get_unchecked(i) * w.get_unchecked(i);
            }
        }
        22 => {
            //q_data[i] = (J[i + Q * 0] * J[i + Q * 3] - J[i + Q * 1] * J[i + Q * 2]) * w[i];
            let q = q as usize;
            for i in 0..q {
                q_data[i] = (j.get_unchecked(i) * j.get_unchecked(i + q * 3)
                    - j.get_unchecked(i + q) * j.get_unchecked(i + q * 2))
                    * w.get_unchecked(i);
            }
        }
        33 => {
            let q = q as usize;
            for i in 0..q {
                q_data[i] = (j.get_unchecked(i)
                    * (j.get_unchecked(i + q * 4) * j.get_unchecked(i + q * 8)
                        - j.get_unchecked(i + q * 5) * j.get_unchecked(i + q * 7))
                    - j.get_unchecked(i + q * 1)
                        * (j.get_unchecked(i + q * 3) * j.get_unchecked(i + q * 8)
                            - j.get_unchecked(i + q * 5) * j.get_unchecked(i + q * 6))
                    + j.get_unchecked(i + q * 2)
                        * (j.get_unchecked(i + q * 3) * j.get_unchecked(i + q * 7)
                            - j.get_unchecked(i + q * 4) * j.get_unchecked(i + q * 6)))
                    * w[i];
            }
        }
        _ => {
            abort();
        }
    }

    0
}

// /* automatically generated by rust-bindgen 0.72.0 */
// use std::{ffi::c_void, slice};

// pub const _STDINT_H: u32 = 1;
// pub const _FEATURES_H: u32 = 1;
// pub const _DEFAULT_SOURCE: u32 = 1;
// pub const __GLIBC_USE_ISOC2Y: u32 = 0;
// pub const __GLIBC_USE_ISOC23: u32 = 0;
// pub const __USE_ISOC11: u32 = 1;
// pub const __USE_ISOC99: u32 = 1;
// pub const __USE_ISOC95: u32 = 1;
// pub const __USE_POSIX_IMPLICITLY: u32 = 1;
// pub const _POSIX_SOURCE: u32 = 1;
// pub const _POSIX_C_SOURCE: u32 = 200809;
// pub const __USE_POSIX: u32 = 1;
// pub const __USE_POSIX2: u32 = 1;
// pub const __USE_POSIX199309: u32 = 1;
// pub const __USE_POSIX199506: u32 = 1;
// pub const __USE_XOPEN2K: u32 = 1;
// pub const __USE_XOPEN2K8: u32 = 1;
// pub const _ATFILE_SOURCE: u32 = 1;
// pub const __WORDSIZE: u32 = 64;
// pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
// pub const __SYSCALL_WORDSIZE: u32 = 64;
// pub const __TIMESIZE: u32 = 64;
// pub const __USE_TIME_BITS64: u32 = 1;
// pub const __USE_MISC: u32 = 1;
// pub const __USE_ATFILE: u32 = 1;
// pub const __USE_FORTIFY_LEVEL: u32 = 0;
// pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
// pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
// pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
// pub const _STDC_PREDEF_H: u32 = 1;
// pub const __STDC_IEC_559__: u32 = 1;
// pub const __STDC_IEC_60559_BFP__: u32 = 201404;
// pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
// pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
// pub const __STDC_ISO_10646__: u32 = 201706;
// pub const __GNU_LIBRARY__: u32 = 6;
// pub const __GLIBC__: u32 = 2;
// pub const __GLIBC_MINOR__: u32 = 41;
// pub const _SYS_CDEFS_H: u32 = 1;
// pub const __glibc_c99_flexarr_available: u32 = 1;
// pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
// pub const __HAVE_GENERIC_SELECTION: u32 = 1;
// pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
// pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
// pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
// pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
// pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
// pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
// pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
// pub const _BITS_TYPES_H: u32 = 1;
// pub const _BITS_TYPESIZES_H: u32 = 1;
// pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
// pub const __INO_T_MATCHES_INO64_T: u32 = 1;
// pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
// pub const __STATFS_MATCHES_STATFS64: u32 = 1;
// pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
// pub const __FD_SETSIZE: u32 = 1024;
// pub const _BITS_TIME64_H: u32 = 1;
// pub const _BITS_WCHAR_H: u32 = 1;
// pub const _BITS_STDINT_INTN_H: u32 = 1;
// pub const _BITS_STDINT_UINTN_H: u32 = 1;
// pub const _BITS_STDINT_LEAST_H: u32 = 1;
// pub const INT8_MIN: i32 = -128;
// pub const INT16_MIN: i32 = -32768;
// pub const INT32_MIN: i32 = -2147483648;
// pub const INT8_MAX: u32 = 127;
// pub const INT16_MAX: u32 = 32767;
// pub const INT32_MAX: u32 = 2147483647;
// pub const UINT8_MAX: u32 = 255;
// pub const UINT16_MAX: u32 = 65535;
// pub const UINT32_MAX: u32 = 4294967295;
// pub const INT_LEAST8_MIN: i32 = -128;
// pub const INT_LEAST16_MIN: i32 = -32768;
// pub const INT_LEAST32_MIN: i32 = -2147483648;
// pub const INT_LEAST8_MAX: u32 = 127;
// pub const INT_LEAST16_MAX: u32 = 32767;
// pub const INT_LEAST32_MAX: u32 = 2147483647;
// pub const UINT_LEAST8_MAX: u32 = 255;
// pub const UINT_LEAST16_MAX: u32 = 65535;
// pub const UINT_LEAST32_MAX: u32 = 4294967295;
// pub const INT_FAST8_MIN: i32 = -128;
// pub const INT_FAST16_MIN: i64 = -9223372036854775808;
// pub const INT_FAST32_MIN: i64 = -9223372036854775808;
// pub const INT_FAST8_MAX: u32 = 127;
// pub const INT_FAST16_MAX: u64 = 9223372036854775807;
// pub const INT_FAST32_MAX: u64 = 9223372036854775807;
// pub const UINT_FAST8_MAX: u32 = 255;
// pub const UINT_FAST16_MAX: i32 = -1;
// pub const UINT_FAST32_MAX: i32 = -1;
// pub const INTPTR_MIN: i64 = -9223372036854775808;
// pub const INTPTR_MAX: u64 = 9223372036854775807;
// pub const UINTPTR_MAX: i32 = -1;
// pub const PTRDIFF_MIN: i64 = -9223372036854775808;
// pub const PTRDIFF_MAX: u64 = 9223372036854775807;
// pub const SIG_ATOMIC_MIN: i32 = -2147483648;
// pub const SIG_ATOMIC_MAX: u32 = 2147483647;
// pub const SIZE_MAX: i32 = -1;
// pub const WINT_MIN: u32 = 0;
// pub const WINT_MAX: u32 = 4294967295;
// pub const CeedInt_FMT: &[u8; 2] = b"d\0";
// pub const CeedSize_FMT: &[u8; 3] = b"td\0";
// pub const CeedInt8_FMT: &[u8; 2] = b"d\0";
// pub const CEED_EPSILON: f64 = 0.0000000000000001;
// pub type wchar_t = ::std::os::raw::c_int;
// #[repr(C)]
// #[repr(align(16))]
// #[derive(Debug, Copy, Clone)]
// pub struct max_align_t {
//     pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
//     pub __bindgen_padding_0: u64,
//     pub __clang_max_align_nonce2: u128,
// }
// #[allow(clippy::unnecessary_operation, clippy::identity_op)]
// const _: () = {
//     ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
//     ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
//     ["Offset of field: max_align_t::__clang_max_align_nonce1"]
//         [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
//     ["Offset of field: max_align_t::__clang_max_align_nonce2"]
//         [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
// };
// pub type __u_char = ::std::os::raw::c_uchar;
// pub type __u_short = ::std::os::raw::c_ushort;
// pub type __u_int = ::std::os::raw::c_uint;
// pub type __u_long = ::std::os::raw::c_ulong;
// pub type __int8_t = ::std::os::raw::c_schar;
// pub type __uint8_t = ::std::os::raw::c_uchar;
// pub type __int16_t = ::std::os::raw::c_short;
// pub type __uint16_t = ::std::os::raw::c_ushort;
// pub type __int32_t = ::std::os::raw::c_int;
// pub type __uint32_t = ::std::os::raw::c_uint;
// pub type __int64_t = ::std::os::raw::c_long;
// pub type __uint64_t = ::std::os::raw::c_ulong;
// pub type __int_least8_t = __int8_t;
// pub type __uint_least8_t = __uint8_t;
// pub type __int_least16_t = __int16_t;
// pub type __uint_least16_t = __uint16_t;
// pub type __int_least32_t = __int32_t;
// pub type __uint_least32_t = __uint32_t;
// pub type __int_least64_t = __int64_t;
// pub type __uint_least64_t = __uint64_t;
// pub type __quad_t = ::std::os::raw::c_long;
// pub type __u_quad_t = ::std::os::raw::c_ulong;
// pub type __intmax_t = ::std::os::raw::c_long;
// pub type __uintmax_t = ::std::os::raw::c_ulong;
// pub type __dev_t = ::std::os::raw::c_ulong;
// pub type __uid_t = ::std::os::raw::c_uint;
// pub type __gid_t = ::std::os::raw::c_uint;
// pub type __ino_t = ::std::os::raw::c_ulong;
// pub type __ino64_t = ::std::os::raw::c_ulong;
// pub type __mode_t = ::std::os::raw::c_uint;
// pub type __nlink_t = ::std::os::raw::c_ulong;
// pub type __off_t = ::std::os::raw::c_long;
// pub type __off64_t = ::std::os::raw::c_long;
// pub type __pid_t = ::std::os::raw::c_int;
// #[repr(C)]
// #[derive(Debug, Copy, Clone)]
// pub struct __fsid_t {
//     pub __val: [::std::os::raw::c_int; 2usize],
// }
// #[allow(clippy::unnecessary_operation, clippy::identity_op)]
// const _: () = {
//     ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
//     ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
//     ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
// };
// pub type __clock_t = ::std::os::raw::c_long;
// pub type __rlim_t = ::std::os::raw::c_ulong;
// pub type __rlim64_t = ::std::os::raw::c_ulong;
// pub type __id_t = ::std::os::raw::c_uint;
// pub type __time_t = ::std::os::raw::c_long;
// pub type __useconds_t = ::std::os::raw::c_uint;
// pub type __suseconds_t = ::std::os::raw::c_long;
// pub type __suseconds64_t = ::std::os::raw::c_long;
// pub type __daddr_t = ::std::os::raw::c_int;
// pub type __key_t = ::std::os::raw::c_int;
// pub type __clockid_t = ::std::os::raw::c_int;
// pub type __timer_t = *mut ::std::os::raw::c_void;
// pub type __blksize_t = ::std::os::raw::c_long;
// pub type __blkcnt_t = ::std::os::raw::c_long;
// pub type __blkcnt64_t = ::std::os::raw::c_long;
// pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
// pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
// pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
// pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
// pub type __fsword_t = ::std::os::raw::c_long;
// pub type __ssize_t = ::std::os::raw::c_long;
// pub type __syscall_slong_t = ::std::os::raw::c_long;
// pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
// pub type __loff_t = __off64_t;
// pub type __caddr_t = *mut ::std::os::raw::c_char;
// pub type __intptr_t = ::std::os::raw::c_long;
// pub type __socklen_t = ::std::os::raw::c_uint;
// pub type __sig_atomic_t = ::std::os::raw::c_int;
// pub type int_least8_t = __int_least8_t;
// pub type int_least16_t = __int_least16_t;
// pub type int_least32_t = __int_least32_t;
// pub type int_least64_t = __int_least64_t;
// pub type uint_least8_t = __uint_least8_t;
// pub type uint_least16_t = __uint_least16_t;
// pub type uint_least32_t = __uint_least32_t;
// pub type uint_least64_t = __uint_least64_t;
// pub type int_fast8_t = ::std::os::raw::c_schar;
// pub type int_fast16_t = ::std::os::raw::c_long;
// pub type int_fast32_t = ::std::os::raw::c_long;
// pub type int_fast64_t = ::std::os::raw::c_long;
// pub type uint_fast8_t = ::std::os::raw::c_uchar;
// pub type uint_fast16_t = ::std::os::raw::c_ulong;
// pub type uint_fast32_t = ::std::os::raw::c_ulong;
// pub type uint_fast64_t = ::std::os::raw::c_ulong;
// pub type intmax_t = __intmax_t;
// pub type uintmax_t = __uintmax_t;
// #[doc = " Integer type, used for indexing\n @ingroup Ceed"]
// pub type CeedInt = i32;
// #[doc = " Integer type, used array sizes\n @ingroup Ceed"]
// pub type CeedSize = isize;
// #[doc = " Integer type, for small integers\n @ingroup Ceed"]
// pub type CeedInt8 = ::std::os::raw::c_schar;
// #[doc = " Single precision"]
// pub const CeedScalarType_CEED_SCALAR_FP32: CeedScalarType = 0;
// #[doc = " Double precision"]
// pub const CeedScalarType_CEED_SCALAR_FP64: CeedScalarType = 1;
// #[doc = " Scalar (floating point) types\n\n @ingroup Ceed"]
// pub type CeedScalarType = ::std::os::raw::c_uint;
// pub type CeedScalar = f64;
// #[doc = " Success error code"]
// pub const CeedErrorType_CEED_ERROR_SUCCESS: CeedErrorType = 0;
// #[doc = " Minor error, generic"]
// pub const CeedErrorType_CEED_ERROR_MINOR: CeedErrorType = 1;
// #[doc = " Minor error, dimension mismatch in inputs"]
// pub const CeedErrorType_CEED_ERROR_DIMENSION: CeedErrorType = 2;
// #[doc = " Minor error, incomplete object setup"]
// pub const CeedErrorType_CEED_ERROR_INCOMPLETE: CeedErrorType = 3;
// #[doc = " Minor error, incompatible arguments/configuration"]
// pub const CeedErrorType_CEED_ERROR_INCOMPATIBLE: CeedErrorType = 4;
// #[doc = " Minor error, access lock problem"]
// pub const CeedErrorType_CEED_ERROR_ACCESS: CeedErrorType = 5;
// #[doc = " Major error, generic"]
// pub const CeedErrorType_CEED_ERROR_MAJOR: CeedErrorType = -1;
// #[doc = " Major error, internal backend error"]
// pub const CeedErrorType_CEED_ERROR_BACKEND: CeedErrorType = -2;
// #[doc = " Major error, operation unsupported by current backend"]
// pub const CeedErrorType_CEED_ERROR_UNSUPPORTED: CeedErrorType = -3;
// #[doc = " Ceed error code.\n\n This enum is used to specify the type of error returned by a function.\n A zero error code is success, negative error codes indicate terminal errors and positive error codes indicate nonterminal errors.\n With nonterminal errors the object state has not been modified, but with terminal errors the object data is likely modified or corrupted.\n @ingroup Ceed"]
// pub type CeedErrorType = ::std::os::raw::c_int;
// #[doc = " Memory resides on the host"]
// pub const CeedMemType_CEED_MEM_HOST: CeedMemType = 0;
// #[doc = " Memory resides on a device (corresponding to \\ref Ceed resource)"]
// pub const CeedMemType_CEED_MEM_DEVICE: CeedMemType = 1;
// #[doc = " Specify memory type.\n Many Ceed interfaces take or return pointers to memory.\n This enum is used to specify where the memory being provided or requested must reside.\n @ingroup Ceed"]
// pub type CeedMemType = ::std::os::raw::c_uint;
// #[doc = " Implementation will copy the values and not store the passed pointer."]
// pub const CeedCopyMode_CEED_COPY_VALUES: CeedCopyMode = 0;
// #[doc = " Implementation can use and modify the data provided by the user, but does not take ownership."]
// pub const CeedCopyMode_CEED_USE_POINTER: CeedCopyMode = 1;
// #[doc = " Implementation takes ownership of the pointer and will free using CeedFree() when done using it.\n The user should not assume that the pointer remains valid after ownership has been transferred.\n Note that arrays allocated using C++ operator new or other allocators cannot generally be freed using CeedFree().\n CeedFree() is capable of freeing any memory that can be freed using free()."]
// pub const CeedCopyMode_CEED_OWN_POINTER: CeedCopyMode = 2;
// #[doc = " Conveys ownership status of arrays passed to Ceed interfaces.\n @ingroup Ceed"]
// pub type CeedCopyMode = ::std::os::raw::c_uint;
// #[doc = " \\f$\\Vert \\bm{x}\\Vert_1 = \\sum_i \\vert x_i\\vert\\f$"]
// pub const CeedNormType_CEED_NORM_1: CeedNormType = 0;
// #[doc = " \\f$\\Vert \\bm{x} \\Vert_2 = \\sqrt{\\sum_i x_i^2}\\f$"]
// pub const CeedNormType_CEED_NORM_2: CeedNormType = 1;
// #[doc = " \\f$\\Vert \\bm{x} \\Vert_\\infty = \\max_i \\vert x_i \\vert\\f$"]
// pub const CeedNormType_CEED_NORM_MAX: CeedNormType = 2;
// #[doc = " Denotes type of vector norm to be computed\n @ingroup CeedVector"]
// pub type CeedNormType = ::std::os::raw::c_uint;
// #[doc = " Apply the linear transformation"]
// pub const CeedTransposeMode_CEED_NOTRANSPOSE: CeedTransposeMode = 0;
// #[doc = " Apply the transpose"]
// pub const CeedTransposeMode_CEED_TRANSPOSE: CeedTransposeMode = 1;
// #[doc = " Denotes whether a linear transformation or its transpose should be applied\n @ingroup CeedBasis"]
// pub type CeedTransposeMode = ::std::os::raw::c_uint;
// #[doc = " Perform no evaluation (either because there is no data or it is already at quadrature points)"]
// pub const CeedEvalMode_CEED_EVAL_NONE: CeedEvalMode = 0;
// #[doc = " Interpolate from nodes to quadrature points"]
// pub const CeedEvalMode_CEED_EVAL_INTERP: CeedEvalMode = 1;
// #[doc = " Evaluate gradients at quadrature points from input in the basis"]
// pub const CeedEvalMode_CEED_EVAL_GRAD: CeedEvalMode = 2;
// #[doc = " Evaluate divergence at quadrature points from input in the basis"]
// pub const CeedEvalMode_CEED_EVAL_DIV: CeedEvalMode = 4;
// #[doc = " Evaluate curl at quadrature points from input in the basis"]
// pub const CeedEvalMode_CEED_EVAL_CURL: CeedEvalMode = 8;
// #[doc = " Using no input, evaluate quadrature weights on the reference element"]
// pub const CeedEvalMode_CEED_EVAL_WEIGHT: CeedEvalMode = 16;
// #[doc = " Basis evaluation mode\n @ingroup CeedBasis"]
// pub type CeedEvalMode = ::std::os::raw::c_uint;
// #[doc = " Gauss-Legendre quadrature"]
// pub const CeedQuadMode_CEED_GAUSS: CeedQuadMode = 0;
// #[doc = " Gauss-Legendre-Lobatto quadrature"]
// pub const CeedQuadMode_CEED_GAUSS_LOBATTO: CeedQuadMode = 1;
// #[doc = " Type of quadrature; also used for location of nodes\n @ingroup CeedBasis"]
// pub type CeedQuadMode = ::std::os::raw::c_uint;
// #[doc = " Line"]
// pub const CeedElemTopology_CEED_TOPOLOGY_LINE: CeedElemTopology = 65536;
// #[doc = " Triangle - 2D shape"]
// pub const CeedElemTopology_CEED_TOPOLOGY_TRIANGLE: CeedElemTopology = 131073;
// #[doc = " Quadralateral - 2D shape"]
// pub const CeedElemTopology_CEED_TOPOLOGY_QUAD: CeedElemTopology = 131074;
// #[doc = " Tetrahedron - 3D shape"]
// pub const CeedElemTopology_CEED_TOPOLOGY_TET: CeedElemTopology = 196611;
// #[doc = " Pyramid - 3D shape"]
// pub const CeedElemTopology_CEED_TOPOLOGY_PYRAMID: CeedElemTopology = 196612;
// #[doc = " Prism - 3D shape"]
// pub const CeedElemTopology_CEED_TOPOLOGY_PRISM: CeedElemTopology = 196613;
// #[doc = " Hexehedron - 3D shape"]
// pub const CeedElemTopology_CEED_TOPOLOGY_HEX: CeedElemTopology = 196614;
// #[doc = " Type of basis shape to create non-tensor element basis.\n Dimension can be extracted with bitwise AND (CeedElemTopology & 2**(dim + 2)) == TRUE\n @ingroup CeedBasis"]
// pub type CeedElemTopology = ::std::os::raw::c_uint;
// #[doc = " Double precision value"]
// pub const CeedContextFieldType_CEED_CONTEXT_FIELD_DOUBLE: CeedContextFieldType = 1;
// #[doc = " 32 bit integer value"]
// pub const CeedContextFieldType_CEED_CONTEXT_FIELD_INT32: CeedContextFieldType = 2;
// #[doc = " Boolean value"]
// pub const CeedContextFieldType_CEED_CONTEXT_FIELD_BOOL: CeedContextFieldType = 3;
// #[doc = " Denotes type of data stored in a CeedQFunctionContext field\n @ingroup CeedQFunction"]
// pub type CeedContextFieldType = ::std::os::raw::c_uint;
// #[doc = " A structure used to pass additional data to f_build_mass"]
// #[repr(C)]
// #[derive(Debug, Copy, Clone)]
// pub struct BuildContext {
//     pub dim: CeedInt,
//     pub space_dim: CeedInt,
// }
// #[allow(clippy::unnecessary_operation, clippy::identity_op)]
// const _: () = {
//     ["Size of BuildContext"][::std::mem::size_of::<BuildContext>() - 8usize];
//     ["Alignment of BuildContext"][::std::mem::align_of::<BuildContext>() - 4usize];
//     ["Offset of field: BuildContext::dim"][::std::mem::offset_of!(BuildContext, dim) - 0usize];
//     ["Offset of field: BuildContext::space_dim"]
//         [::std::mem::offset_of!(BuildContext, space_dim) - 4usize];
// };
// #[doc = " libCEED Q-function for building quadrature data for a mass operator"]
// pub const build_mass_loc: &[u8; 41] = b"../examples/ceed/ex1-volume.h:build_mass\0";
// #[doc = " libCEED Q-function for applying a mass operator"]
//pub const apply_mass_loc: &[u8; 41] = b"../examples/ceed/ex1-volume.h:apply_mass\0";
